// package main

// import (
// 	"fmt"
// 	"net/http"
// 	"strconv"
// 	"time"

// 	"github.com/gin-gonic/gin"
// 	"github.com/golang-jwt/jwt/v4"
// )

// var jwtKey = []byte("your_secret_key")

// // Credentials structure with exported field names
// type Credentials struct {
// 	ID 			 int 		`json:"id"`
// 	Email    string `json:"email"`
// 	Password string `json:"password"`
// 	Username string `json:"username"`
// 	Role     string `json:"role"`
// }

// // List of valid credentials
// var users = []Credentials{
// 	{ID:1, Email: "johndoe@gmail.com", Password: "123", Username: "John Doe", Role: "Software Engineer"},
// 	{ID:2, Email: "johncole@yopmail.com", Password: "1223", Username: "John Coltrane", Role: "IT Support"},
// 	{ID:3,  Email: "testuser@gmail.com", Password: "1223", Username: "Test User", Role: "Tester"},
// }

// // Claims structure for JWT tokens
// type Claims struct {
// 	Email string `json:"email"`
// 	jwt.RegisteredClaims
// }

// // FUNCTION POST LOGIN
// // login handles the authentication logic
// func login(c *gin.Context) {
// 	var creds Credentials
// 	if err := c.ShouldBindJSON(&creds); err != nil {
// 		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
// 		return
// 	}

// 	fmt.Printf("Received credentials: %+v\n", creds)

// 	// Validate credentials by checking against the 'users' array
// 	valid := false
// 	for _, storedCreds := range users {
// 		if creds.Email == storedCreds.Email && creds.Password == storedCreds.Password {
// 			valid = true
// 			break
// 		}
// 	}

// 	// If credentials are invalid, return an error
// 	if !valid {
// 		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials. Check your email or password"})
// 		return
// 	}

// 	// Create JWT token on successful login
// 	expirationTime := time.Now().Add(1 * time.Minute)
// 	claims := &Claims{
// 		Email: creds.Email,
// 		RegisteredClaims: jwt.RegisteredClaims{
// 			ExpiresAt: jwt.NewNumericDate(expirationTime),
// 		},
// 	}

// 	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
// 	tokenString, err := token.SignedString(jwtKey)
// 	if err != nil {
// 		c.JSON(http.StatusInternalServerError, gin.H{"error": "Could not generate token"})
// 		return
// 	}

// 	c.JSON(http.StatusOK, gin.H{"token": tokenString})
// }

// // FUNCTION GET USER LIST
// func getUser(c *gin.Context) {
// 	c.IndentedJSON(http.StatusOK, users)
// }

// // FUNCTION GET USER BY ID
// func getUserByID(c *gin.Context) {
// 	idParam := c.Param("id")

// 	// Convert id from string to int
// 	id, err := strconv.Atoi(idParam)
// 	if err != nil {
// 		c.IndentedJSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
// 		return
// 	}

// 	for _, a := range users {
// 		if a.ID == id {
// 			c.IndentedJSON(http.StatusOK, a)
// 			return
// 		}
// 	}

// 	c.IndentedJSON(http.StatusNotFound, gin.H{"message": "User not found"})
// }

// func main() {
// 	r := gin.Default()
// 	r.POST("/login", login)	// Post Login Route
// 	r.GET("/user", getUser)// Get User Route
// 	r.GET("/user/:id", getUserByID)	//Get User by ID
// 	r.Run(":8082")
// }

